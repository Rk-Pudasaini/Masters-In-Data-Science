---
title: "Assignmnet3_2"
author: "Ram Krishna Pudasaini"
date: "2023-05-08"
output: html_document
---

**Use the attached twitter data in r data format and do as follows:**

**1. Load the attached "termDocMatrix.rdata" file in R/R studio**

```{r}
#Load the attached "termDocMatrix.rdata" file in R/R studio
load("Ram Krishna Pudasaini - termDocMatrix.rdata")
```

**2. Check the structure of this data and comment on it carefully**

```{r}
#Check the structure of this data, we can use the str() function:
str(termDocMatrix)
```

From the structure of the data we can find out that there are 21 rows and 154 columns in the data set and the dimension name Terms consist 21 character elements and dimension name Docs Consist 154 Columns with values.

**3. Inspect the first 10 rows and first 10 columns of this data using sub-setting**

```{r}
#Inspect the first 10 rows and first 10 columns of this data using sub-setting
termDocMatrix[1:10,1:10]
```

**4. Convert the loaded termDocMatrix data to as matrix with appropriate R code**

```{r}
#Convert the loaded termDocMatrix data to as matrix with appropriate R code
termMatrix <- as.matrix(termDocMatrix)
```

**5. Change this matrix to a Boolean matrix with same name (Hint: [termDocMatrix \>=1] \< 1)**

```{r}
#convert a matrix to a Boolean matrix where all non-zero values are replaced with 1
termMatrix[termMatrix >= 1] <- 1
print(termMatrix)
```

6.  **Transform this matrix to a term-term adjacency matrix as termMatrix object (Hint: Use %\*% and t(termDocMatrix)**

```{r}
#converting to term adjacency matrix using matrix multiplication and 
#transposing the matrix with t() function 
termAdjMatrix <- termMatrix %*% t(termMatrix)
print(termAdjMatrix)

```

**7. Inspect the first 10 rows and first 10 columns of this matrix using sub-setting**

```{r}
#Inspect the first 10 rows and first 10 columns of this matrix using sub-setting
termAdjMatrix[1:10,1:10]
```

8.  **Define a graph object g of termMatrix using graph.adjacency function of "igraph" package with weighted=T and mode="undirected" arguments in the function**

```{r}
library(igraph)
g <- graph.adjacency(termAdjMatrix, weighted = TRUE, mode = "undirected")
plot(g)
```

9.  **Remove loops of g using simplify function**

```{r}
#Remove loops of g using simplify function
g <- simplify(g, remove.loops = TRUE)
plot(g)
```

**10. Set vertices labels with names of g**

```{r}
#Set vertices labels with names of g
V(g)$label <- V(g)$name
plot(g)
```

**11. Set degree with degree of g**

```{r}
#Set degree with degree of g
degree <- degree(g)
```

**12. Find degree of g for 'all", "in" and "out" modes and interpret them carefully**

```{r}
#Find degree of g for 'all", "in" and "out" nodes and interpret them carefully
(degree_all <- degree(g, mode = "all"))
(degree_in <- degree(g, mode = "in"))
(degree_out <- degree(g, mode = "out"))
```

The **degree_all** object contains the degree of each vertex in g, regardless of direction. The **degree_in** object contains the degree of each vertex in g which are inwards in direction. The degree_out object contains the degree of each vertices in g which are outward in direction from each node.

**13. Find diameter of g and interpret it carefully** The diameter of graph is the maximum distance between the pair of vertices. It can also be defined as the maximal distance between the pair of vertices. Way to solve it is to find all the paths and then find the maximum of all.Â 

```{r}
#Find diameter of g and interpret it carefully
diameter <- diameter(g)
diameter

```

In this case, the diameter of **`g`** is 5. This means that the longest path between any two terms in the Twitter data is 5, which indicates that the terms are moderately connected.

**14 Find edge density of g and interpret it carefully**

```{r}
#Find edge density of g and interpret it carefully
(edge_density <- edge_density(g))
```

The density of a graph is the ratio of the number of edges and the number of possible edge. It is the proportion of the possible edges that are actually present in the graph. In this case, the edge density of **`g`** is 0.62. This indicates that the terms in the Twitter data are somehow connected with wime fraction of the possible connections **(i.e 0.6 )**actually present in the graph.

**15. Find reciprocity of g and interpret it carefully**

```{r}
#reciprocity of g
(reciprocity <- reciprocity(g))
```

The reciprocity of a graph is the proportion of pairs of vertices that are connected by edges in both directions. In this case, the reciprocity of **`g`** is 1 which indicates that the terms in the Twitter data are mostly connected in both directions.

**16. Find closeness of g and interpret it carefully**

```{r}
#closeness between terms
(closeness <- closeness(g))

```

The closeness of a vertex in a graph is a measure of how close it is to all other vertices in the graph. In this case, the closeness object contains the closeness centrality of each term in the Twitter data. Terms with high closeness centrality are highly connected to other terms in the data, while terms with low closeness centrality are less connected.

**17. Find betweenness of g and interpret it carefully**

```{r}
#Find between of g and interpret it carefully
(betweenness <- betweenness(g))
```

The betweenness of a vertex in a graph is a measure of how often it appears on the shortest path between other vertices in the graph. In this case, the **`betweenness`** object contains the betweness centrality of each term in the Twitter data. Terms with high betweenness centrality are important for maintaining connections between other terms in the data, while terms with low betweenness centrality are less important for maintaining these connections.

18\. Plot histogram of node degree and interpret it carefully

```{r}
#Plot histogram of node degree and interpret it carefully
hist(degree, xlab = "Degree", main = "Histogram of Node Degree")

```

This will produce a histogram of the node degree distribution, showing the frequency of terms with different degrees in the Twitter data. This histogram can provide insight into the structure of the network, such as whether it is scale-free or random.

**19. Set seed as per your class roll number**

```{r}
set.seed(26)
```

**20 Plot g with vertex.size of degree\*0.4 and interpret it carefully**

```{r}
#plot g with vertex.size of degree*0.4 and interpret it carefully
plot(g, vertex.size = degree*0.4)
```

This will produce a plot of the graph **`g`**, where the size of each vertex is proportional to its degree by 0.4.

**21. plot g with fruchterman.reingold layout and interpret it carefully**

```{r}
#plot g with fruchterman.reingold layout and interpret it carefully
plot(g, layout = layout.fruchterman.reingold, vertex.size = degree(g) * 0.4)
```

**22 plot g with kamada.kawai layout and interpret it carefully**

```{r}
#plot g with kamada.kawai layout and interpret it carefully
plot(g, layout = layout.kamada.kawai, vertex.size = degree(g) * 0.4)
```

The **layout.kamada.kawai** function places vertices such that the sum of spring forces and electrical forces is minimized. This layout tends to group vertices that are more closely related to each other, and spread out vertices that are less related. The resulting plot shows a clear clustering of vertices in the center of the graph, with a few outliers on the edges. The vertex size is proportional to the degree of the vertex

**23 plot hub and authority of g and interpret them carefully**

```{r}
#plot hub and authority of g and interpret them carefully
hubs <- hub_score(g)
hubVector <- hubs$vector
auths <- authority_score(g)
authVector <- auths$vector
plot(hubVector, type = "l", xlab = "Nodes", ylab = "Hub Scores")
plot(authVector, type = "l", xlab = "Nodes", ylab = "Authority Scores")

```

**24 Plot community cluster of g and interpret it carefully**

```{r}
#Plot community cluster of g and interpret it carefully
communities <- cluster_edge_betweenness(g)
plot(communities, g)

```

**25. Write a summary of SNA for the twitter data**

In this analysis, we loaded a term-document matrix of tweets and converted it to a Boolean matrix and a term-term adjacency matrix. We then created a graph object using the **`igraph`** package and removed loops, set vertex labels, and calculated degrees. We analyzed various properties of the resulting graph, including degree distribution, diameter, edge density, reciprocity, closeness, betweenness, and community structure.

The degree distribution plot showed the connection between each vertices. Here we find the inward and out degree of each vertices. The diameter of the graph was 5, indicating that it was easy to navigate from one vertex to another with the longest path distance as 5. The edge density was 0.62 suggesting that terms of twitter data are colsely related. The reciprocity of **`g`** is 1 which indicates that the terms in the Twitter data are mostly connected in both directions.

The closeness analysis contains the closeness centrality of each term in the Twitter data. Terms with high closeness centrality are highly connected to other terms in the data, while terms with low closeness centrality are less connected. Finally, the community structure revealed distinct groups of related vertices that were centered around certain hubs and authorities.

Overall, this analysis demonstrates how SNA can be used to gain insights into the structure and properties of complex networks, such as social media interactions.
